
core "unhosted apps + user-hosted service" spec
  - unhosted app means an application that runs in the browser, with no server-side code. the app's statics are hosted, but its execution is not. it's synonymous to client-side app, and to html5 app.
  - user-hosted service is a relative term - the service itself /is/ hosted somewhere, but it is dynamically linked to the unhosted app, independent of the app, but dependent on the user. The identity-confirmation service provided by an IdP in protocols like OpenID, BrowserID, and SAML is example of a user-hosted service (although the RP is not usually an unhosted app in any of those examples).
  - recognized user-hosted service (or "service"): a user-hosted service that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized discovery mechanism: a discovery mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - recognized auth mechanism: an auth mechanism that is described on either our 'stable' or our 'experimental' short-list. Both lists are maintained by the Unhosted W3C CG, as is this spec.
  - server: an http service that offers at least one user-hosted service for at least one user, plus at least one of our discovery mechanisms, and at least one of our auth mechanisms, in such a way that the 3 work together, i.e., all its services are discoverable through all its discovery mechanisms, and can be authed through all its auth mechanisms.
  - even if, through redirects there are many different and even unrelated pysical servers involved in offering the combination of discovery, auth and service, we still call it one server. for instance, maybe your discovery and for instance your storage are served by unrelated companies, you just made one point to the other, we still model that as one server.
  - setting:
    - user brings: [web app identifier, server identifier, user identifier, sufficient credentials for user@server]
    - device: lets the user
    - user interface: lets the user interact with the device
    - device: ties together user interface, runtime, http client, chrome.
    - app: an unhosted app
    - api: lets the app interact with the user and the server.
    - chrome: any interface for the user to interact with, that is neiher part of the app, nor of the server interface
    - interactions:user interaction (device OS), app interaction (html5), service interaction (http, html5)
  - discovery mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app knowing which services are available
  - auth mechanism
      -> a self-explanatory interaction of user-browser, user-app, browser-service, app-service, and user-service, that results in the app having access to the services which the user wants it to have access to.
  - service
      -> something that can go on http+cors, or WebSocket, or JSONP, or outgoing GET, or some other cross-domain way for the app to communicate with something dynamically linked.
- since most current user agents don't implement any of this, usually the 'user-agent' role is folded into the 'unhosted app' role, using an "unhosted app player" js library

generic part:
-start with user[user identifier, server identifier, credentials, app identifier], and agent
user->agent: app identifier
-add appserver[app code, lib code]
appserver->agent: app code, lib code
-add app[app code], lib[lib code]
app->user: start screen
lib->user: login box
user->lib: user identifier, server identifier

discovery mechanism 'webfinger-based':
-add server[host-meta, map(user identifier->lrdd)]
server->lib: host-meta
lib->server: user identifier
server->lib: user's lrdd
-if successful, lib now has extracted from the user's lrdd a list of services, and for each one the following data:
  -service type
  -service params
  -foreach supported auth mechanism:
    -auth mechanism type
    -auth mechanism params
lib->app: service types

auth mechanism OAuth-based:
-start with user[user identifier, server identifier, credentials, app identifier], agent, app[app code[scopes], service types], lib[lib code, user identifier, server identifier, auth mechanism params:[popupPath]]
app->lib: service type, scopes
lib->agent: popupUrl[server identifier, popupPath, scopes]
agent->server: popupUrl[server identifier, popupPath, scopes]
server->agent: dialog code
-add dialog[dialog code]
dialog->user: start screen
user->dialog: decision
dialog->server:decision
server->agent:token
agent->lib:token
lib->app:ACK

app-initiated service access:
app[app code[scopes], service types], lib[libcode[map(service type, action, actionParams->requestType, requestParams, map(responseParams->result))],lrdd,token]
app->lib:service type, action, actionParams
lib->server:requestType,requestParams, token
server->lib:responseParams
lib->app:result

for now, we're modelling server-initiated and bidirectional services and app-to-app services all as if they were app-initiated services, using for instance the 'callback' pattern like the one often used in javascript.
